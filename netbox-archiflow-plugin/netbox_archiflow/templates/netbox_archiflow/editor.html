{% extends 'netbox_archiflow/plugin_base.html' %}

{% block title %}Diagram Editor - ArchiFlow{% endblock %}

{% block breadcrumbs %}
    <li class="breadcrumb-item active">Editor</li>
{% endblock %}

{% block extra_styles %}
<style>
    .version-manager {
        background: #f0fdf4;
        border: 2px solid #10b981;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }

    .version-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .site-selector {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .version-table {
        background: white;
        border-radius: 4px;
        max-height: 200px;
        overflow-y: auto;
    }

    .version-table table {
        width: 100%;
        margin: 0;
    }

    .version-table th {
        background: #f6f8fa;
        font-size: 12px;
        padding: 8px;
    }

    .version-table td {
        font-size: 12px;
        padding: 6px 8px;
    }

    .live-badge {
        background: #10b981;
        color: white;
        padding: 2px 6px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: bold;
    }

    .btn-xs {
        padding: 2px 8px;
        font-size: 11px;
    }

    #version-toggle {
        cursor: pointer;
        user-select: none;
    }

    .version-content {
        transition: all 0.3s ease;
    }

    .version-content.collapsed {
        display: none;
    }

    /* Save status indicator styles */
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }

    .saving {
        animation: pulse 1s infinite;
        color: #f59e0b;
    }

    .saved {
        color: #10b981;
    }

    .error {
        color: #ef4444;
    }
</style>
{% endblock %}

{% block content %}
{% csrf_token %}
<div class="row">
    <div class="col-12">
        <!-- Version Manager Section (Green Box) -->
        <div class="version-manager" id="version-manager">
            <div class="version-header">
                <div class="site-selector">
                    <label style="margin: 0; margin-right: 10px;">Site:</label>
                    <select id="site-select" class="form-select form-select-sm" style="width: 200px; display: inline-block;">
                        <option value="">Loading sites...</option>
                    </select>
                    <button class="btn btn-sm btn-success" onclick="createNewVersion()" style="margin-left: 10px;">
                        + New Diagram
                    </button>
                    <button class="btn btn-sm btn-primary" onclick="saveCurrentDiagram()" style="margin-left: 5px;">
                        üíæ Save Current
                    </button>
                    <span id="save-status" style="margin-left: 10px; font-size: 12px; color: #666;">
                        <span id="save-indicator"></span>
                    </span>
                </div>

            <div class="version-content" id="version-content">
                <div class="version-table">
                    <table class="table table-sm table-hover">
                        <thead>
                            <tr>
                                <th>Site</th>
                                <th>Version</th>
                                <th>Title</th>
                                <th>Status</th>
                                <th>Created</th>
                                <th>Author</th>
                                <th>Live</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="version-list">
                            <tr>
                                <td colspan="8" class="text-center text-muted">
                                    Select a site to view diagrams
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Draw.io Editor -->
        <div class="card">
            <div class="card-header">
                <h3>ArchiFlow Network Diagram Editor</h3>
                <small id="current-diagram-info" class="text-muted"></small>
            </div>
            <div class="card-body p-0">
                <div style="height: 70vh;">
                    <iframe
                        id="archiflow-frame"
                        src="about:blank"
                        style="width: 100%; height: 100%; border: none;">
                    </iframe>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
// Error handler to catch issues
window.addEventListener('error', (e) => {
    console.error('JavaScript Error:', e.message, 'at line', e.lineno);
});

// Version Manager functionality
let ws = null;
let currentSite = null;
let currentDiagram = null;
let sites = [];
let diagrams = [];

// Connect to ArchiFlow WebSocket
let isConnecting = false;
let reconnectAttempts = 0;

function connectWebSocket() {
    if (isConnecting || (ws && ws.readyState === WebSocket.OPEN)) {
        console.log('Already connected or connecting');
        return;
    }

    isConnecting = true;
    console.log('Attempting to connect to WebSocket...');
    ws = new WebSocket('ws://localhost:3333');

    ws.onopen = () => {
        console.log('‚úÖ Connected to ArchiFlow WebSocket');
        isConnecting = false;
        reconnectAttempts = 0;

        // Load fresh sites from NetBox and sync to ArchiFlow DB
        loadSitesDirectly();

        // Also request sites from ArchiFlow DB after a short delay
        setTimeout(() => { // Wait for plugin to load
            console.log('Requesting sites from ArchiFlow DB...');
            sendToWebSocket('get_sites');
        }, 5000); // 5 seconds for plugin to initialize
    };

    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        handleWebSocketResponse(data);
    };

    ws.onerror = (error) => {
        console.error('‚ùå WebSocket error:', error);
        isConnecting = false;

        // Try to load sites from NetBox API as fallback
        console.log('üì• Falling back to NetBox API for sites...');
        loadSitesDirectly();

        // Show error message to user
        const dropdown = document.getElementById('site-select-simple');
        if (dropdown && dropdown.options.length <= 1) {
            dropdown.innerHTML = '<option value="">WebSocket error - Using cached data</option>';
        }
    };

    ws.onclose = () => {
        console.log('WebSocket disconnected');
        isConnecting = false;

        // Only reconnect if we haven't tried too many times
        if (reconnectAttempts < 3) {
            reconnectAttempts++;
            setTimeout(connectWebSocket, 5000);
        }
    };
}

// Send message to WebSocket
function sendToWebSocket(action, params = {}) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        const message = { action, ...params };
        console.log('üì® Sending to WebSocket:', message);
        ws.send(JSON.stringify(message));
    } else {
        console.warn('‚ö†Ô∏è WebSocket not open, cannot send:', action);
    }
}

// Handle WebSocket responses
function handleWebSocketResponse(data) {
    console.log('üì® WebSocket response received:', data);
    console.log('Response type:', data.type);
    console.log('Response action:', data.action);

    if (data.type === 'welcome') {
        console.log('‚úÖ WebSocket welcome message received');
        // Don't auto-load sites here, already loaded in onopen
    } else if (data.action === 'get_sites') {
        console.log('Sites received from WebSocket:', data.sites);
        if (data.sites && data.sites.length > 0) {
            sites = data.sites;
            populateDropdown(sites);
        }
    } else if (data.action === 'get_diagrams_by_site') {
        console.log('Received diagrams:', data.diagrams);
        diagrams = data.diagrams || [];
        updateVersionTable();
    } else if (data.action === 'deploy_version') {
        if (data.success) {
            alert('Version deployed successfully!');
            loadDiagrams(currentSite);
        }
    } else if (data.action === 'sync_sites') {
        console.log('‚úÖ Sites synced to ArchiFlow DB:', data);
        // After syncing, request the sites back to update dropdown
        console.log('üì• Requesting sites after sync...');
        setTimeout(() => { // Wait for plugin to load
            sendToWebSocket('get_sites');
        }, 500);
    } else {
        console.log('üì® Other response:', data.action || data.type);
    }
}

// Load sites from NetBox through our plugin API
function loadSitesDirectly() {
    console.log('Loading sites from NetBox...');

    const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]')?.value ||
                      getCookie('csrftoken');

    // Use our plugin's API endpoint which has access to NetBox models
    fetch('/plugins/archiflow/api/sites/', {
        method: 'GET',
        headers: {
            'Accept': 'application/json',
            'X-CSRFToken': csrftoken
        },
        credentials: 'same-origin'
    })
    .then(response => {
        console.log('Sites API response status:', response.status);
        if (!response.ok) throw new Error('API error: ' + response.status);
        return response.json();
    })
    .then(data => {
        console.log('Sites loaded from NetBox:', data);
        console.log('Data type:', typeof data);
        console.log('Is array:', Array.isArray(data));

        // Make sure we have an array
        const sitesArray = Array.isArray(data) ? data : (data.results || []);
        console.log('Sites array:', sitesArray);

        // Transform to our format
        const sitesList = sitesArray.map(site => ({
            id: site.id,
            name: site.name,
            slug: site.slug,
            status: site.status || 'active',
            description: site.description || ''
        }));

        console.log('Processed sites:', sitesList);
        console.log('Setting global sites variable...');

        // Update dropdown immediately
        sites = sitesList;
        populateDropdown(sites);

        // Sync to ArchiFlow DB
        if (sitesList.length > 0) {
            console.log('Syncing sites to ArchiFlow DB:', sitesList);
            if (ws && ws.readyState === WebSocket.OPEN) {
                sendToWebSocket('sync_sites', { sites: sitesList });
                console.log('Sites sync sent via WebSocket');
            } else {
                console.warn('WebSocket not ready, saving sites for later sync');
                // Store for later when WebSocket connects
                window.pendingSitesSync = sitesList;
            }
        }
    })
    .catch(error => {
        console.error('‚ùå Error loading sites from NetBox:', error);

        // Update dropdown with error message
        const dropdown = document.getElementById('site-select-simple');
        if (dropdown) {
            dropdown.innerHTML = '<option value="">Error loading sites - Check console</option>';
        }

        // As last resort, try to get from ArchiFlow DB
        console.log('üì• Falling back to ArchiFlow DB...');
        if (ws && ws.readyState === WebSocket.OPEN) {
            sendToWebSocket('get_sites');
        } else {
            console.error('‚ùå WebSocket not available for fallback');
            // Try with hardcoded sites for testing
            console.log('üß™ Using hardcoded sites for testing...');
            sites = [
                { id: 1, name: 'TLV-DC-01', slug: 'tlv-dc-01', status: 'active', description: 'Test site' },
                { id: 4, name: 'RishonLetzion', slug: 'rishonletzion', status: 'active', description: 'Test site' }
            ];
            updateSiteDropdown();
        }
    });
}


// Helper function to get cookie value
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Load sites from ArchiFlow
function loadSites() {
    sendToWebSocket('get_sites');
}

// SIMPLE function to populate dropdown
function populateDropdown(sitesArray) {
    const dropdown = document.getElementById('site-select');
    if (!dropdown) return;

    console.log('Populating dropdown with', sitesArray?.length || 0, 'sites');

    // DESTROY TOM SELECT IF IT EXISTS
    if (dropdown.tomselect) {
        console.log('Destroying Tom Select to populate...');
        dropdown.tomselect.destroy();
    }

    // Clear it
    dropdown.innerHTML = '';

    // Add default
    dropdown.add(new Option('Select a site...', ''));

    // Add sites
    if (sitesArray && sitesArray.length > 0) {
        sitesArray.forEach(site => {
            dropdown.add(new Option(site.name, site.id));
        });
        console.log('‚úÖ Added', sitesArray.length, 'sites to dropdown');

        // Make sure it stays visible
        dropdown.style.display = 'inline-block';
        dropdown.style.visibility = 'visible';
    }
}

// Update site dropdown wrapper
function updateSiteDropdown() {
    populateDropdown(sites);
}

// Load diagrams for selected site
function loadDiagrams(siteId) {
    if (!siteId) return;

    currentSite = siteId;
    sendToWebSocket('get_diagrams_by_site', { siteId });
}

// Update version table
function updateVersionTable() {
    const tbody = document.getElementById('version-list');

    if (diagrams.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="7" class="text-center text-muted">
                    No diagrams found for this site
                </td>
            </tr>
        `;
        return;
    }

    tbody.innerHTML = diagrams.map(d => {
        // Get site name from our loaded sites or use the stored one
        const siteName = sites.find(s => s.id == d.site_id)?.name || d.site_name || 'Unknown Site';

        return `
        <tr style="${d.is_live ? 'background:#f0fdf4' : ''}">
            <td>${siteName}</td>
            <td>${d.version}</td>
            <td>${d.title}</td>
            <td>
                <span class="badge badge-${d.status === 'deployed' ? 'success' : 'secondary'}">
                    ${d.status}
                </span>
            </td>
            <td>${new Date(d.created_at).toLocaleDateString()}</td>
            <td>${d.created_by}</td>
            <td>${d.is_live ? '<span class="live-badge">LIVE</span>' : ''}</td>
            <td>
                <button class="btn btn-xs btn-primary" onclick="openDiagram('${d.id}')">
                    Open
                </button>
                ${!d.is_live ? `
                    <button class="btn btn-xs btn-success" onclick="deployVersion('${d.id}')">
                        Deploy
                    </button>
                ` : ''}
            </td>
        </tr>
        `;
    }).join('');
}

// Open diagram in Draw.io iframe
function openDiagram(diagramId) {
    currentDiagram = diagramId;
    const diagram = diagrams.find(d => d.id === diagramId);

    console.log('Opening diagram:', diagram);
    console.log('Diagram data length:', diagram?.diagram_data?.length || 0);

    // Clear any existing Draw.io storage first
    clearDrawioStorage();

    const iframe = document.getElementById('archiflow-frame');

    // Check if iframe exists before trying to destroy it
    if (!iframe) {
        console.error('No iframe found to replace');
        return;
    }

    // CRITICAL: Completely destroy and recreate the iframe to force a fresh Draw.io instance
    const parent = iframe.parentNode;
    if (!parent) {
        console.error('No parent element found for iframe');
        return;
    }

    // Create a new iframe WITHOUT sandbox to avoid issues
    const newIframe = document.createElement('iframe');
    newIframe.id = 'archiflow-frame';
    newIframe.src = 'about:blank';
    newIframe.style.width = '100%';
    newIframe.style.height = '600px';
    newIframe.style.border = 'none';

    // Don't use sandbox as it's causing issues
    parent.replaceChild(newIframe, iframe);

    // Get the diagram XML or create empty
    let diagramXml = getEmptyDiagram();

    if (diagram && diagram.diagram_data) {
        // Check if the data is valid
        if (diagram.diagram_data.length > 100 && diagram.diagram_data.includes('mxGraphModel')) {
            diagramXml = diagram.diagram_data;
            console.log('‚úÖ Using saved diagram data');
        } else {
            console.log('‚ö†Ô∏è Diagram data seems invalid, using empty diagram');
        }
    } else {
        console.log('üìù No diagram data found, creating new');
    }

    // Build the URL with the diagram data embedded
    const encodedXml = encodeURIComponent(diagramXml);

    setTimeout(() => {
        // Use the ArchiFlow loader but with cache-busting parameters
        const timestamp = new Date().getTime();
        const randomId = Math.random().toString(36).substring(7);

        // Create a data URI with the empty diagram to force Draw.io to load it
        // Use unique IDs to prevent any caching
        const uniqueId = `${timestamp}-${randomId}`;
        const emptyDiagram = `<mxfile><diagram id="${uniqueId}" name="Page-${uniqueId}"><mxGraphModel dx="1422" dy="762" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169"><root><mxCell id="0"/><mxCell id="1" parent="0"/></root></mxGraphModel></diagram></mxfile>`;
        const dataUri = `data:application/xml;base64,${btoa(emptyDiagram)}`;

        // Load via ArchiFlow loader with the empty diagram in URL
        const drawioUrl = `http://localhost:8081/archiflow-loader.html?t=${timestamp}&rid=${randomId}&data=${encodeURIComponent(dataUri)}`;

        console.log('Loading fresh Draw.io instance with empty diagram data');
        newIframe.src = drawioUrl;

        // Wait for Draw.io to load, then send the diagram
        newIframe.onload = function() {
            setTimeout(() => { // Wait for plugin to load
                console.log("üì§ Sending diagram to Draw.io via postMessage...");
                console.log("  Current diagram ID:", diagramId);
                console.log("  Full XML being sent:");
                console.log(diagramXml);
                console.log("  XML contains ROUTER:", diagramXml.includes('ROUTER'));
                console.log("  XML contains value=:", diagramXml.includes('value='));

                // Send the diagram directly - don't use pendingDiagramLoad which may be stale
                newIframe.contentWindow.postMessage({
                    action: "load",
                    xml: diagramXml,
                    title: diagram ? diagram.title : "Untitled",
                    autosave: false,
                    forceNew: true  // Signal to clear everything first
                }, "*");
                console.log("‚úÖ Sent diagram, XML length:", diagramXml.length);


                // Inject save interceptor script
                try {
                    console.log('Injecting save interceptor...');
                    const script = newIframe.contentDocument.createElement('script');
                    script.src = '/archiflow-save-interceptor.js?t=' + Date.now();
                    newIframe.contentDocument.head.appendChild(script);
                } catch (e) {
                    console.log('Could not inject script (cross-origin):', e);
                }
            }, 7000); // 7 seconds for plugin to fully initialize and clear
        };
    }, 100);

    // Update info
    if (diagram) {
        document.getElementById('current-diagram-info').textContent =
            `Currently editing: ${diagram.version} - ${diagram.title} ${diagram.is_live ? '(LIVE)' : ''}`;
    }

    // Reset save status
    updateSaveStatus('saved');
    isDirty = false;
}

// Helper function to create empty diagram
function getEmptyDiagram() {
    return `<mxfile host="app.diagrams.net" modified="${new Date().toISOString()}" agent="ArchiFlow" version="1.0">
        <diagram name="Page-1" id="archiflow">
            <mxGraphModel dx="1422" dy="762" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169">
                <root>
                    <mxCell id="0"/>
                    <mxCell id="1" parent="0"/>
                </root>
            </mxGraphModel>
        </diagram>
    </mxfile>`;
}

// Save status management
let saveStatusElement;
let autoSaveTimer = null;
let lastSaveTime = null;
let isDirty = false;

function updateSaveStatus(status, message) {
    if (!saveStatusElement) {
        saveStatusElement = document.getElementById('save-indicator');
    }
    if (!saveStatusElement) return;

    saveStatusElement.className = '';

    switch(status) {
        case 'saving':
            saveStatusElement.className = 'saving';
            saveStatusElement.textContent = '‚è≥ Saving...';
            break;
        case 'saved':
            saveStatusElement.className = 'saved';
            lastSaveTime = new Date();
            saveStatusElement.textContent = `‚úÖ Saved at ${lastSaveTime.toLocaleTimeString()}`;
            isDirty = false;
            break;
        case 'error':
            saveStatusElement.className = 'error';
            saveStatusElement.textContent = `‚ùå Save failed: ${message || 'Unknown error'}`;
            break;
        case 'dirty':
            saveStatusElement.className = '';
            saveStatusElement.textContent = 'üìù Unsaved changes';
            isDirty = true;
            break;
        default:
            saveStatusElement.textContent = '';
    }
}

// Save diagram to database
function saveDiagramToDatabase(xmlData, isAutoSave = false) {
    if (!currentDiagram || !xmlData) {
        console.warn('No diagram selected or no data to save');
        console.warn('  - currentDiagram:', currentDiagram);
        console.warn('  - xmlData:', xmlData ? 'present' : 'missing');
        return;
    }

    console.log('üì§ saveDiagramToDatabase called', isAutoSave ? '(auto-save)' : '(manual)');
    console.log('  - Diagram ID:', currentDiagram);
    console.log('  - XML type:', typeof xmlData);
    console.log('  - XML length:', xmlData.length, 'bytes');

    // Check if this is actually empty
    const hasContent = xmlData.includes('value=') || xmlData.includes('style=') || xmlData.includes('vertex') || xmlData.includes('edge');
    console.log('  - Has actual content:', hasContent);
    console.log('  - XML preview:', xmlData.substring(0, 300));

    updateSaveStatus('saving');

    // Prepare message for WebSocket
    const wsMessage = {
        diagramId: currentDiagram,
        diagramData: xmlData,
        userId: '{{ user.username }}',
        isAutoSave: isAutoSave
    };

    console.log('üì° Sending to WebSocket:', {
        action: 'update_diagram',
        diagramId: wsMessage.diagramId,
        dataLength: wsMessage.diagramData.length
    });

    // Send to WebSocket to save
    sendToWebSocket('update_diagram', wsMessage);

    // The success/error will be handled by WebSocket response
    // For now, optimistically assume success
    setTimeout(() => { // Wait for plugin to load
        updateSaveStatus('saved');
        if (!isAutoSave) {
            // Only show alert for manual saves
            alert('‚úÖ Diagram saved to database!');
        }
    }, 500);

    // Reload the diagrams list to show updated timestamp
    if (currentSite) {
        setTimeout(() => loadDiagrams(currentSite), 500);
    }
}

// Function to explicitly save current diagram
function saveCurrentDiagram(isAutoSave = false) {
    if (!currentDiagram) {
        if (!isAutoSave) {
            alert('Please open a diagram first');
        }
        return;
    }

    const iframe = document.getElementById('archiflow-frame');

    console.log('Requesting current diagram XML from Draw.io...', isAutoSave ? '(auto-save)' : '(manual)');

    // Store auto-save flag for use in message handler
    window.pendingAutoSave = isAutoSave;

    // Method 1: Try to get the diagram from Draw.io's localStorage
    try {
        // Try to access iframe's localStorage (may not work due to cross-origin)
        const iframeWindow = iframe.contentWindow;

        // Send multiple types of export messages
        // This is what Draw.io expects based on their API
        iframeWindow.postMessage(JSON.stringify({
            action: 'export',
            format: 'xmlsvg',
            xml: 1,
            grid: 0,
            base64: 0
        }), '*');

        // Also try the simple format
        setTimeout(() => { // Wait for plugin to load
            iframeWindow.postMessage({
                action: 'export',
                format: 'xml'
            }, '*');
        }, 100);

    } catch (e) {
        console.error('Could not access iframe:', e);
    }

    // If we don't get a response in 2 seconds, show manual save dialog
    window.saveTimeout = setTimeout(() => { // Wait for plugin to load
        if (!isAutoSave) {
            // Prompt user to use Ctrl+S inside Draw.io
            alert('Please use Ctrl+S inside the Draw.io editor to save your diagram');
        }
    }, 2000);
}

// Auto-save functionality
function startAutoSave() {
    // Clear any existing timer
    stopAutoSave();

    // Set up auto-save every 30 seconds
    autoSaveTimer = setInterval(() => {
        if (currentDiagram && isDirty) {
            console.log('Auto-saving diagram...');
            saveCurrentDiagram(true);
        }
    }, 30000); // 30 seconds

    console.log('Auto-save enabled (30 second interval)');
}

function stopAutoSave() {
    if (autoSaveTimer) {
        clearInterval(autoSaveTimer);
        autoSaveTimer = null;
        console.log('Auto-save disabled');
    }
}

// Track diagram changes
function markDiagramDirty() {
    if (currentDiagram && !isDirty) {
        updateSaveStatus('dirty');
    }
}

// Keyboard shortcuts
function setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
        // Ctrl+S or Cmd+S to save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
            e.preventDefault();
            if (currentDiagram) {
                saveCurrentDiagram(false);
            }
        }

        // Ctrl+D or Cmd+D to deploy
        if ((e.ctrlKey || e.metaKey) && e.key === 'd') {
            e.preventDefault();
            const diagram = diagrams.find(d => d.id === currentDiagram);
            if (diagram && !diagram.is_live) {
                deployVersion(currentDiagram);
            }
        }
    });

    console.log('Keyboard shortcuts enabled: Ctrl+S to save, Ctrl+D to deploy');
}

// Clear Draw.io local storage
function clearDrawioStorage() {
    // Nuclear clear of ALL storage
    try {
        // Clear ALL localStorage
        localStorage.clear();
        console.log('Cleared localStorage');

        // Clear ALL sessionStorage
        sessionStorage.clear();
        console.log('Cleared sessionStorage');

        // Clear all cookies
        document.cookie.split(";").forEach(function(c) {
            document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
        });
        console.log('Cleared cookies');

        // Try to clear IndexedDB databases
        if (window.indexedDB && indexedDB.databases) {
            indexedDB.databases().then(databases => {
                databases.forEach(db => {
                    indexedDB.deleteDatabase(db.name);
                    console.log('Deleted IndexedDB:', db.name);
                });
            }).catch(e => console.log('Could not access IndexedDB:', e));
        }
    } catch (e) {
        console.log('Could not clear Draw.io storage:', e);
    }
}

// Deploy version as LIVE
function deployVersion(diagramId) {
    if (confirm('Deploy this version as LIVE? The current LIVE version will be archived.')) {
        sendToWebSocket('deploy_version', {
            diagramId,
            userId: '{{ user.username }}'
        });
    }
}

// Create new version
function createNewVersion() {
    if (!currentSite) {
        alert('Please select a site first');
        return;
    }

    const version = prompt('Enter version number (e.g., v1.0):');
    if (version) {
        const title = prompt('Enter diagram title:');
        if (title) {
            // Store the new diagram info in sessionStorage
            sessionStorage.setItem('newDiagram', JSON.stringify({
                siteId: currentSite,
                version: version,
                title: title
            }));

            // Create empty diagram and open editor
            sendToWebSocket('save_version', {
                siteId: currentSite,
                siteName: sites.find(s => s.id == currentSite)?.name || 'Unknown',
                version: version,
                title: title,
                description: 'New diagram',
                diagramData: getEmptyDiagram(),
                userId: '{{ user.username }}'
            });

            // Reload diagrams and auto-open the new one
            setTimeout(() => {
                loadDiagrams(currentSite);

                // Auto-open the new diagram after it's loaded
                setTimeout(() => {
                    const newDiagram = diagrams.find(d =>
                        d.version === version &&
                        d.title === title &&
                        d.site_id == currentSite
                    );
                    if (newDiagram) {
                        console.log('Auto-opening new diagram:', newDiagram.id);
                        openDiagram(newDiagram.id);
                    }
                }, 1000);
            }, 500);
        }
    }
}

// Refresh sites - manual trigger for testing
function refreshSites() {
    console.log('üîÑ Manual refresh triggered');

    // Method 1: Load from NetBox API
    console.log('üì• Loading from NetBox API...');
    loadSitesDirectly();

    // Method 2: Request from ArchiFlow DB
    setTimeout(() => { // Wait for plugin to load
        console.log('üì• Requesting from ArchiFlow DB...');
        sendToWebSocket('get_sites');
    }, 5000); // 5 seconds for plugin to initialize
}

// Test function to directly call get_sites
function testGetSites() {
    console.log('üß™ TEST: Directly calling get_sites');
    if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('‚úÖ WebSocket is open, sending get_sites');
        sendToWebSocket('get_sites');
    } else {
        console.log('‚ùå WebSocket not open, state:', ws ? ws.readyState : 'null');
    }
}

// Make test function globally accessible
window.testGetSites = testGetSites;

// Debug function to check dropdown
window.checkDropdown = function() {
    const dropdown = document.getElementById('site-select');
    console.log('=== DROPDOWN DEBUG ===');
    console.log('Dropdown exists:', !!dropdown);
    if (dropdown) {
        console.log('Options count:', dropdown.options.length);
        console.log('Current value:', dropdown.value);
        console.log('Visible:', dropdown.style.display !== 'none');
        console.log('Parent:', dropdown.parentElement);

        // Check for Tom Select
        if (dropdown.tomselect) {
            console.log('‚ö†Ô∏è TOM SELECT IS ACTIVE!');
            console.log('Tom Select options:', Object.keys(dropdown.tomselect.options));
        } else {
            console.log('‚úÖ No Tom Select (good!)');
        }

        // List all options
        for(let i = 0; i < dropdown.options.length; i++) {
            console.log(`  Option ${i}: "${dropdown.options[i].text}" (value: ${dropdown.options[i].value})`);
        }
    }
    console.log('Global sites variable:', sites);
    console.log('===================');
};

// Site selection handler - SIMPLE VERSION
document.addEventListener('DOMContentLoaded', () => {
    // Initialize save status element
    saveStatusElement = document.getElementById('save-indicator');

    // Set up keyboard shortcuts
    setupKeyboardShortcuts();

    // Start auto-save timer
    startAutoSave();

    // Site selector event
    const siteSelect = document.getElementById('site-select');
    if (siteSelect) {
        siteSelect.addEventListener('change', (e) => {
            console.log('Site selected:', e.target.value);
            if (e.target.value) {
                loadDiagrams(e.target.value);
            }
        });
    }

    // Track when user opens a diagram
    const originalOpenDiagram = window.openDiagram;
    window.openDiagram = function(diagramId) {
        originalOpenDiagram(diagramId);
        // Reset save status when opening a new diagram
        updateSaveStatus('saved');
        isDirty = false;
    };
});

// Removed toggle functionality - no longer needed

// Original Draw.io integration code
window.addEventListener('load', function() {
    console.log('Page loaded, checking for iframe...');
    const iframe = document.getElementById('archiflow-frame');

    if (!iframe) {
        console.error('CRITICAL: No iframe found on page load!');
        // Create the iframe if it doesn't exist
        const editorDiv = document.querySelector('.card-body') || document.body;
        const newIframe = document.createElement('iframe');
        newIframe.id = 'archiflow-frame';
        newIframe.src = 'about:blank';
        newIframe.style.width = '100%';
        newIframe.style.height = '600px';
        newIframe.style.border = 'none';
        editorDiv.appendChild(newIframe);
        console.log('Created missing iframe');
        return;
    }

    // Load Draw.io with minimal parameters
    // iframe.src = "http://localhost:8081/archiflow-loader.html?splash=0"; // DISABLED - Load only when diagram selected

    // Connect to WebSocket for version management
    connectWebSocket();

    // PREVENT TOM SELECT FROM INITIALIZING TOO EARLY
    const dropdown = document.getElementById('site-select');
    if (dropdown && dropdown.tomselect) {
        console.log('Destroying early Tom Select...');
        dropdown.tomselect.destroy();
    }

    // Load sites from database on page load
    setTimeout(() => { // Wait for plugin to load
        console.log('Loading sites from database...');

        // Method 1: Try WebSocket
        if (ws && ws.readyState === WebSocket.OPEN) {
            console.log('Requesting sites via WebSocket...');
            sendToWebSocket('get_sites');
        }

        // Method 2: Try NetBox API (as backup)
        setTimeout(() => { // Wait for plugin to load
            loadSitesDirectly();
        }, 500);
    }, 5000); // 5 seconds for plugin to initialize

    // Handle messages from Draw.io
    window.addEventListener('message', function(event) {
        if (event.origin !== 'http://localhost:8081') {
            return;
        }

        const message = event.data;

        if (message.event === 'init') {
            console.log('Draw.io initialized');
            // Send NetBox context to Draw.io
            iframe.contentWindow.postMessage({
                action: 'netbox-context',
                context: {
                    user: '{{ user.username }}',
                    userId: '{{ user.id }}',
                    email: '{{ user.email }}',
                    isSuperuser: {{ user.is_superuser|yesno:"true,false" }},
                    currentSite: currentSite,
                    currentDiagram: currentDiagram
                }
            }, 'http://localhost:8081');
        } else if (message.event === 'save') {
            console.log("üì• Diagram save event received", message);
            console.log("Current Diagram ID:", currentDiagram);
            console.log("XML present:", !!message.xml);
            console.log("XML type:", typeof message.xml);
            console.log("XML length:", message.xml ? message.xml.length : 0);
            console.log("XML preview:", message.xml ? message.xml.substring(0, 200) : 'No XML');

            if (currentDiagram && message.xml) {
                console.log("‚úÖ Saving to database...");
                console.log("  - Diagram ID:", currentDiagram);
                console.log("  - XML size:", message.xml.length, "bytes");
                saveDiagramToDatabase(message.xml);
            } else {
                console.error("‚ùå Cannot save:");
                console.error("  - currentDiagram:", currentDiagram);
                console.error("  - xml present:", !!message.xml);
                console.error("  - xml length:", message.xml ? message.xml.length : 0);
            }
        } else if (message.event === 'autosave') {
            console.log('Diagram autosave event received');
            if (currentDiagram && message.xml) {
                saveDiagramToDatabase(message.xml);
            }
        } else if (message.event === 'export') {
            console.log('Diagram export response received:', message);

            // Clear save timeout
            if (window.saveTimeout) {
                clearTimeout(window.saveTimeout);
                window.saveTimeout = null;
            }

            // Get the XML data from the message
            let xmlData = message.xml || message.data || message.content;

            if (!xmlData && message.message) {
                // Sometimes the data is in a message property
                try {
                    const parsed = JSON.parse(message.message);
                    xmlData = parsed.xml || parsed.data;
                } catch (e) {
                    // Not JSON
                }
            }

            if (xmlData) {
                // If it's base64, decode it
                if (typeof xmlData === 'string' && xmlData.includes('base64,')) {
                    const base64Data = xmlData.split('base64,')[1];
                    xmlData = atob(base64Data);
                }

                console.log('Got export data from Draw.io, length:', xmlData.length);
                // Save the exported diagram
                if (currentDiagram) {
                    saveDiagramToDatabase(xmlData, false);
                }
            }
        } else if (message.event === "ready") {
            console.log("Draw.io ready");
        }
    });
});
</script>
{% endblock %}